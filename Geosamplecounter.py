# This code was generated by AI CodeGuruX as well as with Google Gemini 2.5
# Version 1.6 - Fixed UnboundLocalError in create_style_normal function

import csv
import xml.etree.ElementTree as ET
from xml.dom import minidom
import math

# Global variable to store the number of rows (used for initial CSV read)
numCount = 0

def read_csv_and_extract_data(file_path):
    """
    Reads a CSV file, extracts latitude, longitude, and SS_RSRP values.
    Updates the global numCount with the number of valid rows found.

    Args:
        file_path (str): The path to the CSV file.

    Returns:
        tuple: A tuple containing lists of latitude, longitude, and SS_RSRP values.
    """
    global numCount
    latitude_values = []
    longitude_values = []
    ss_rsrp_values = []

    try:
        with open(file_path, mode='r', newline='', encoding='utf-8') as csvfile:
            csvreader = csv.DictReader(csvfile)

            for row in csvreader:
                # Extract values from the specified columns
                latitude = row.get('latitude')
                longitude = row.get('longitude')
                ss_rsrp = row.get('SS_RSRP')

                # Check if the row has valid data for all required columns
                if latitude and longitude and ss_rsrp:
                    try:
                        latitude_values.append(float(latitude))
                        longitude_values.append(float(longitude))
                        ss_rsrp_values.append(float(ss_rsrp))
                        numCount += 1
                    except ValueError:
                        # Skip rows with non-numeric data in these columns
                        print(f"Skipping row due to non-numeric data in latitude, longitude, or SS_RSRP: {row}")
                else:
                    print(f"Skipping row due to missing required data: {row}")
    except FileNotFoundError:
        print(f"Error: CSV file not found at '{file_path}'")
        raise # Re-raise to be caught in main()
    except Exception as e:
        print(f"An error occurred while reading the CSV file: {e}")
        raise # Re-raise to be caught in main()

    return latitude_values, longitude_values, ss_rsrp_values

# The calculate_color_gradient function has been removed as per your request.
# All polygons will now use a fixed green color.

def calculate_rectangle_corners(center_lat, center_lon, side_length=4):
    """
    Calculates the corner coordinates of a square rectangle centered at a given
    latitude and longitude, with a specified side length in meters.

    Args:
        center_lat (float): The latitude of the rectangle's center.
        center_lon (float): The longitude of the rectangle's center.
        side_length (float): The side length of the square in meters.

    Returns:
        tuple: A tuple containing the longitude and latitude coordinates of the
                four corners, plus the first corner repeated to close the polygon
                in the order (lon1, lat1, lon2, lat2, lon3, lat3, lon4, lat4, lon1, lat1).
    """
    # Earth's radius in meters (WGS84 ellipsoid mean radius)
    earth_radius = 6378137

    # Convert center latitude to radians for calculations involving cosine
    lat_rad = math.radians(center_lat)

    # Calculate the angular distance for half of the side length
    # for both latitude and longitude
    half_side_angular_lat = (side_length / 2) / earth_radius
    # For longitude, the distance in degrees changes with latitude (cosine of latitude)
    # Avoid division by zero if latitude is exactly +/-90 (poles), although unlikely for real data
    cos_lat = math.cos(lat_rad)
    half_side_angular_lon = (side_length / 2) / (earth_radius * (cos_lat if cos_lat != 0 else 1e-6))


    # Calculate the offset in degrees for latitude and longitude
    offset_lat_deg = math.degrees(half_side_angular_lat)
    offset_lon_deg = math.degrees(half_side_angular_lon)

    # Calculate the coordinates of the four corners, rounded to 5 decimal places
    # Top-right
    lat1 = round(center_lat + offset_lat_deg, 5)
    lon1 = round(center_lon + offset_lon_deg, 5)

    # Top-left
    lat2 = round(center_lat + offset_lat_deg, 5)
    lon2 = round(center_lon - offset_lon_deg, 5)

    # Bottom-left
    lat3 = round(center_lat - offset_lat_deg, 5)
    lon3 = round(center_lon - offset_lon_deg, 5)

    # Bottom-right
    lat4 = round(center_lat - offset_lat_deg, 5)
    lon4 = round(center_lon + offset_lon_deg, 5)

    # Return the coordinates in the specific (lon, lat) order required by KML
    # The last point repeats the first to properly close the polygon in KML
    return (lon1, lat1, lon2, lat2, lon3, lat3, lon4, lat4, lon1, lat1)

def bin_data(latitude_values, longitude_values, ss_rsrp_values, bin_side_length=4):
    """
    Bins the geographical data into square cells and calculates the sample count
    for each bin. Average SS_RSRP is no longer calculated or stored.

    Args:
        latitude_values (list): List of latitudes.
        longitude_values (list): List of longitudes.
        ss_rsrp_values (list): List of SS_RSRP values (still needed for iteration, but not for average).
        bin_side_length (int): Side length of the square bin in meters.

    Returns:
        dict: A dictionary where keys are (lat_idx, lon_idx) tuples and values
              are dictionaries containing 'center_lat', 'center_lon',
              and 'sample_count' for each bin.
    """
    binned_data = {}
    earth_radius = 6378137 # Earth's radius in meters

    if not latitude_values or not longitude_values:
        return binned_data

    # Find the bounding box of the data
    min_lat = min(latitude_values)
    max_lat = max(latitude_values)
    min_lon = min(longitude_values)
    max_lon = max(longitude_values)

    # Calculate approximate degrees per meter for latitude and longitude
    # Use average latitude for longitude calculation to be more accurate
    avg_lat_rad = math.radians((min_lat + max_lat) / 2)
    
    # Degrees per meter for latitude (approx. constant, assuming WGS84)
    deg_lat_per_meter = 1 / (earth_radius * (math.pi / 180))
    # Degrees per meter for longitude (varies with cosine of latitude)
    cos_avg_lat = math.cos(avg_lat_rad)
    deg_lon_per_meter = 1 / (earth_radius * (cos_avg_lat if cos_avg_lat != 0 else 1e-6) * (math.pi / 180))

    # Calculate the size of a bin in degrees based on the desired meter size
    bin_lat_deg = bin_side_length * deg_lat_per_meter
    bin_lon_deg = bin_side_length * deg_lon_per_meter

    for i in range(len(latitude_values)):
        lat = latitude_values[i]
        lon = longitude_values[i]
        # ss_rsrp is no longer used for averaging, but iterating through original data is necessary

        # Calculate bin indices relative to the minimum latitude/longitude
        lat_idx = int(math.floor((lat - min_lat) / bin_lat_deg))
        lon_idx = int(math.floor((lon - min_lon) / bin_lon_deg))

        bin_key = (lat_idx, lon_idx)

        if bin_key not in binned_data:
            # Calculate center of the new bin
            center_lat = min_lat + (lat_idx + 0.5) * bin_lat_deg
            center_lon = min_lon + (lon_idx + 0.5) * bin_lon_deg
            
            binned_data[bin_key] = {
                'center_lat': center_lat,
                'center_lon': center_lon,
                'sample_count': 0
            }
        
        binned_data[bin_key]['sample_count'] += 1
    
    # No average RSRP calculation needed here anymore
    return binned_data

def create_stylemap_elements(document, num_bins):
    """
    Creates KML StyleMap elements for each data point, linking normal and
    highlighted styles.

    Args:
        document (ET.Element): The KML Document element to append styles to.
        num_bins (int): The total number of data bins (and therefore styles).
    """
    for i in range(num_bins):
        # Create the StyleMap element with a unique ID
        style_map = ET.SubElement(document, 'StyleMap', id=f'msn_ylw-pushpin{i}')

        # Create the first Pair element for the 'normal' state
        pair1 = ET.SubElement(style_map, 'Pair')
        key1 = ET.SubElement(pair1, 'key')
        key1.text = 'normal'
        style_url1 = ET.SubElement(pair1, 'styleUrl')
        style_url1.text = f'#sn_ylw-pushpin{i}' # Reference to the normal style

        # Create the second Pair element for the 'highlight' state
        pair2 = ET.SubElement(style_map, 'Pair')
        key2 = ET.SubElement(pair2, 'key')
        key2.text = 'highlight'
        style_url2 = ET.SubElement(pair2, 'styleUrl')
        style_url2.text = f'#sh_ylw-pushpin{i}' # Reference to the highlight style

def create_style_highlight(document, num_bins):
    """
    Creates KML Style elements for the highlighted state of each data point,
    using a fixed green color.

    Args:
        document (ET.Element): The KML Document element to append styles to.
        num_bins (int): The total number of data bins.
    """
    fixed_green_kml_color = '8000FF00' # AABBGGRR: 50% opacity, Blue 00, Green FF, Red 00

    for i in range(num_bins):
        # Create the Style element for highlight state with a unique ID
        style = ET.SubElement(document, 'Style', id=f"sh_ylw-pushpin{i}")

        # IconStyle for the pushpin icon when highlighted
        icon_style = ET.SubElement(style, 'IconStyle')
        scale = ET.SubElement(icon_style, 'scale')
        scale.text = '1.3' # Slightly larger scale for highlight

        icon = ET.SubElement(icon_style, 'Icon')
        href = ET.SubElement(icon, 'href')
        href.text = 'http://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png' # Google Earth default pushpin

        hot_spot = ET.SubElement(icon_style, 'hotSpot', x="20", y="2", xunits="pixels", yunits="pixels")

        # BalloonStyle (can be empty if no custom balloon content is desired)
        balloon_style = ET.SubElement(style, 'BalloonStyle')

        # LineStyle for the polygon outline (set to 0 width to make it invisible)
        line_style = ET.SubElement(style, 'LineStyle')
        width = ET.SubElement(line_style, 'width')
        width.text = '0' # No outline for the polygon

        # PolyStyle for the polygon fill color
        poly_style = ET.SubElement(style, 'PolyStyle')
        color = ET.SubElement(poly_style, 'color')
        color.text = fixed_green_kml_color # Apply fixed green color

def create_style_normal(document, num_bins):
    """
    Creates KML Style elements for the normal state of each data point,
    using a fixed green color.

    Args:
        document (ET.Element): The KML Document element to append styles to.
        num_bins (int): The total number of data bins.
    """
    fixed_green_kml_color = '8000FF00' # AABBGGRR: 50% opacity, Blue 00, Green FF, Red 00

    for i in range(num_bins):
        # Create the Style element for normal state with a unique ID
        style = ET.SubElement(document, 'Style', id=f"sn_ylw-pushpin{i}")

        # IconStyle for the pushpin icon when normal
        icon_style = ET.SubElement(style, 'IconStyle')
        scale = ET.SubElement(icon_style, 'scale')
        scale.text = '1.1' # Normal scale

        icon = ET.SubElement(icon_style, 'Icon')
        href = ET.SubElement(icon, 'href')
        href.text = 'http://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png' # Google Earth default pushpin

        hot_spot = ET.SubElement(icon_style, 'hotSpot', x="20", y="2", xunits="pixels", yunits="pixels")

        # BalloonStyle (can be empty)
        balloon_style = ET.SubElement(style, 'BalloonStyle')

        # LineStyle for the polygon outline (set to 0 width to make it invisible)
        line_style = ET.SubElement(style, 'LineStyle')
        width = ET.SubElement(line_style, 'width')
        width.text = '0' # No outline for the polygon

        # PolyStyle for the polygon fill color
        # CORRECTED: Changed this line to properly define poly_style
        poly_style = ET.SubElement(style, 'PolyStyle')
        color = ET.SubElement(poly_style, 'color')
        color.text = fixed_green_kml_color # Apply fixed green color

def create_placemark(corners_tuple, height, sample_count_label, i):
    """
    Generates the KML string for a single Placemark, representing a rectangular
    polygon with a specified height and referencing a style.
    The sample_count_label is used as the Placemark's name (title).

    Args:
        corners_tuple (tuple): A tuple of (lon, lat) pairs for the rectangle corners,
                               including the first corner repeated at the end to close
                               the polygon (lon1, lat1, lon2, lat2, ..., lon1, lat1).
        height (float): The extrusion height for the polygon (based on sample count).
        sample_count_label (str): The text label for the placemark (e.g., "10").
        i (int): The index of the data bin, used for style referencing.

    Returns:
        str: The KML string for the Placemark.
    """
    # The KML coordinates format is longitude,latitude,altitude.
    # The corners_tuple is (lon1, lat1, lon2, lat2, lon3, lat3, lon4, lat4, lon1, lat1)
    # We need to format it as "lon,lat,alt lon,lat,alt ..."
    coordinates_str = (
        f"{corners_tuple[0]},{corners_tuple[1]},{height} "
        f"{corners_tuple[2]},{corners_tuple[3]},{height} "
        f"{corners_tuple[4]},{corners_tuple[5]},{height} "
        f"{corners_tuple[6]},{corners_tuple[7]},{height} "
        f"{corners_tuple[8]},{corners_tuple[9]},{height}" # Closing the polygon by repeating the first point
    )

    # Generate KML code for the placemark
    # Note: KML uses `styleUrl` to link to StyleMap.
    kml_code = f"""
    <Placemark>
        <name>{sample_count_label}</name> <!-- Label for the polygon (only raw sample count) -->
        <styleUrl>#msn_ylw-pushpin{i}</styleUrl>
        <Polygon>
            <extrude>1</extrude>
            <tessellate>1</tessellate>
            <altitudeMode>relativeToGround</altitudeMode>
            <outerBoundaryIs>
                <LinearRing>
                    <coordinates>
                        {coordinates_str}
                    </coordinates>
                </LinearRing>
            </outerBoundaryIs>
        </Polygon>
    </Placemark>
    """
    return kml_code

def create_label_placemark(center_lat, center_lon, polygon_height, sample_count_label):
    """
    Generates the KML string for a Placemark representing a label at a point.
    This placemark is designed to show the bin's sample count as a floating text label.

    Args:
        center_lat (float): Latitude for the label's position.
        center_lon (float): Longitude for the label's position.
        polygon_height (float): The height of the polygon this label is associated with.
        sample_count_label (str): The text to display as the label (e.g., "10").

    Returns:
        str: The KML string for the label Placemark.
    """
    # Place label slightly above the top of the polygon for visibility
    label_altitude = polygon_height + 0.2

    kml_code = f"""
    <Placemark>
        <name>{sample_count_label}</name> <!-- The text that will be displayed as the label -->
        <Point>
            <altitudeMode>relativeToGround</altitudeMode>
            <coordinates>{center_lon},{center_lat},{label_altitude}</coordinates>
        </Point>
        <Style>
            <LabelStyle>
                <color>ffFFFFFF</color> <!-- White color (AABBGGRR: Alpha Blue Green Red) -->
                <scale>0.7</scale> <!-- Adjust scale as needed for label size -->
            </LabelStyle>
            <IconStyle>
                <scale>0</scale> <!-- Hide the default point icon associated with the label -->
            </IconStyle>
        </Style>
    </Placemark>
    """
    return kml_code


def write_combined_xml(output_filename, num_bins, placemarks_list):
    """
    Generates a complete KML file including styles and placemarks.

    Args:
        output_filename (str): The name of the output KML file.
        num_bins (int): The total number of data bins.
        placemarks_list (list): A list of KML placemark strings.
    """
    # Create the root KML element with necessary namespaces
    kml = ET.Element('kml',
                     xmlns="http://www.opengis.net/kml/2.2",
                     **{
                         'xmlns:gx': "http://www.google.com/kml/ext/2.2",
                         'xmlns:kml': "http://www.opengis.net/kml/2.2",
                         'xmlns:atom': "http://www.w3.org/2005/Atom"
                     }
    )
    # Create the Document element, which is the main container for KML features
    document = ET.SubElement(kml, 'Document')

    # Add the name element for the KML document
    name = ET.SubElement(document, 'name')
    name.text = 'RFmapper_Binned_SampleCount.kml' # Changed KML file name

    # Append StyleMap elements
    create_stylemap_elements(document, num_bins)

    # Append Style elements for highlighted state (no color_values needed)
    create_style_highlight(document, num_bins)

    # Append Style elements for normal state (no color_values needed)
    create_style_normal(document, num_bins)

    # Append Placemark elements by parsing each KML string into an ElementTree object
    for placemark_str in placemarks_list:
        try:
            document.append(ET.fromstring(placemark_str))
        except ET.ParseError as e:
            print(f"Error parsing placemark XML string: {e}\nString: {placemark_str[:100]}...") # Print first 100 chars
            continue # Skip this placemark and try to process others

    # Convert the ElementTree to a byte string with XML declaration
    xml_str_bytes = ET.tostring(kml, encoding='utf-8', xml_declaration=True)

    # Use minidom to pretty print the XML for better readability
    parsed_xml = minidom.parseString(xml_str_bytes)
    # Get the pretty-printed XML string, decoded to utf-8
    pretty_xml_str = parsed_xml.toprettyxml(indent="  ", encoding="utf-8").decode('utf-8')

    # Write the pretty-printed XML string to the specified output file
    try:
        with open(output_filename, 'w', encoding='utf-8') as f:
            f.write(pretty_xml_str)
        print(f"KML file '{output_filename}' created successfully.")
    except IOError as e:
        print(f"Error writing KML file: {e}")

def main():
    """
    Main function to orchestrate reading CSV, processing data, and generating KML.
    """
    # Define the path to your input CSV file
    file_path = '/home/labuser/Tools/SANDBOX2/sample.csv'

    # Initialize global numCount to 0 for each run of main
    global numCount
    numCount = 0

    latitude, longitude, ss_rsrp = [], [], [] # Initialize in case of error
    try:
        # Read the CSV file and extract data
        latitude, longitude, ss_rsrp = read_csv_and_extract_data(file_path)
    except Exception as e:
        # Error message already printed by read_csv_and_extract_data
        return # Exit if file reading fails

    print(f"Number of rows with valid data: {numCount}")

    if numCount == 0:
        print("No valid data found in the CSV file. KML file will not be generated.")
        return

    # Bin the data (SS_RSRP values are passed but not used for averaging in bin_data)
    binned_data = bin_data(latitude, longitude, ss_rsrp, bin_side_length=4)
    
    # Sort bin keys for consistent output order
    sorted_bin_keys = sorted(binned_data.keys())

    # List to store KML placemark strings
    placemarks_list = []
    
    bin_index = 0
    for key in sorted_bin_keys:
        bin_info = binned_data[key]
        
        center_latitude = bin_info['center_lat']
        center_longitude = bin_info['center_lon']
        sample_count = bin_info['sample_count']

        # numHigh is now based on the sample count
        # Ensure a minimum height of 1 to prevent invalid or invisible polygons.
        numhigh = max(1, sample_count) 

        # Create label string for placemark name and floating label (only raw sample count)
        sample_count_label = f"{sample_count}" # Removed "Cnt: " prefix

        # Calculate the corner coordinates for the rectangle
        corners = calculate_rectangle_corners(center_latitude, center_longitude, side_length=4)

        # Generate KML code for the polygon and append to the list
        placemarks_list.append(create_placemark(corners, numhigh, sample_count_label, bin_index))

        # Generate KML code for the label and append to the list
        placemarks_list.append(create_label_placemark(center_latitude, center_longitude, numhigh, sample_count_label))
        
        bin_index += 1

    # Define the output KML filename
    output_kml_filename = 'RFmapper_Binned_SampleCount_output.kml'

    # Write the combined XML (KML) file (no color_values needed in this call)
    write_combined_xml(output_kml_filename, len(binned_data), placemarks_list)

if __name__ == '__main__':
    main()
